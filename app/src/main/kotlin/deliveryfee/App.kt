/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package deliveryfee

import io.ktor.application.*
import io.ktor.features.ContentNegotiation
import io.ktor.http.ContentType
import io.ktor.request.receive
import io.ktor.response.respond
import io.ktor.routing.post
import io.ktor.routing.routing
import io.ktor.serialization.json
import io.ktor.server.engine.embeddedServer
import io.ktor.server.netty.Netty
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import java.time.ZoneOffset
import io.ktor.http.HttpStatusCode
import java.time.DayOfWeek
import java.time.OffsetDateTime


@Serializable
data class DeliveryRequest(
    val cart_value: Int, // cent
    val delivery_distance: Int, //meter
    val number_of_items: Int,
    val time: String // UTC
)

@Serializable
data class DeliveryResponse(
    val delivery_fee: Int
)


fun main() {
    embeddedServer(Netty, port = 8080) {
        install(ContentNegotiation) {
            json(Json { ignoreUnknownKeys = true })
        }

        routing {
            post("/delivery-fee") {
                try {
                    val request = call.receive<DeliveryRequest>()
                    val deliveryFee:Int = calculateDeliveryFee(request)
                    call.respond(DeliveryResponse(deliveryFee))
                } catch (e: Exception) {
                    call.respond(HttpStatusCode.InternalServerError, "Internal Server Error\nDetails: ${e}")
                    e.printStackTrace()
                    println("something went wrong!")
                }
            }
        }
    }.start(wait = true)
    println("App is running!<3")
}


fun calculateDeliveryFee(request: DeliveryRequest): Int {
    try{
        val cartValue = request.cart_value
        val deliveryDistance = request.delivery_distance
        val numberOfItems = request.number_of_items
        val deliveryTime = OffsetDateTime.parse(request.time)

        //100â‚¬ Free delivery?
        if (cartValue >= 10000) {
            val deliveryFee:Int = 0
        return  deliveryFee
        }

        val smallOrderSurcharge: Int = calculateOrderSurcharge(cartValue)
        val distanceFee: Int = calculateDistanceFee(deliveryDistance)
        val itemSurcharge: Int = calculateItemSurcharge(numberOfItems)
        val bulkFee: Int = if (numberOfItems > 12) 120 else 0

        var deliveryFee:Int = distanceFee + itemSurcharge + bulkFee + smallOrderSurcharge

        // Rush Hour?
        if (isRushHour(deliveryTime)) {
            val deliveryFee: Int = calculateRushHourFee(deliveryFee)
            return deliveryFee
        }
        
        // cap 15 euro
        if(deliveryFee >= 1500){deliveryFee = 1500}
        return deliveryFee

        }catch (e: Exception) {
            e.printStackTrace()
            throw e
            println("err: main") 
        }
}


fun calculateOrderSurcharge(cartValue: Int): Int{
    try{
        val surcharges: Int
        surcharges = if (cartValue < 1000) {
            1000 - cartValue
        } else 0

    return surcharges

    }catch (e: Exception) {
        e.printStackTrace()
        throw e
        println("err: calculateOrderSurcharge") 
    }
}


fun calculateDistanceFee(distance: Int): Int {
    try{
        val baseDistanceFee = 200
        val additionalDistance: Int = distance - 1000
        val additionalDistanceFee: Int = if (additionalDistance > 0) {
            100 * (additionalDistance / 500) + if (additionalDistance % 500 != 0) 100 else 0
        } else 0

    return baseDistanceFee + additionalDistanceFee

    }catch (e: Exception) {
        e.printStackTrace()
        throw e
        println("err: calculateDistanceFee")
    }
}


fun calculateItemSurcharge(numberOfItems: Int): Int {
    try{
        val baseItemSurcharge: Int = 50
        var additionalSurcharge: Int = if (numberOfItems >= 5) {
            val extraItems:Int = numberOfItems - 4
             baseItemSurcharge * extraItems 
        } else 0

        //Bulk fee
        additionalSurcharge += if (numberOfItems > 12) 120 else 0


    return additionalSurcharge

    }catch (e: Exception) {
        e.printStackTrace()
        throw e
        println("err: calculateItemSurcharge") 
    }
}


fun isRushHour(deliveryTime: OffsetDateTime): Boolean{
    try{
        val isBetween15pmAnd19pm = deliveryTime.hour in 15..19
        val isFriday = deliveryTime.getDayOfWeek() == DayOfWeek.FRIDAY
    
    return isBetween15pmAnd19pm && isFriday

    }catch (e: Exception) {
        e.printStackTrace()
        throw e
        println("err: isRushHour") 
    }
}


fun calculateRushHourFee(originalFee: Int): Int {
    val updatedFee = originalFee * 12 / 10
    val deliveryFee = if (updatedFee >= 1500) 1500 else updatedFeed
    return deliveryFee
}

// library version
// detailed testing